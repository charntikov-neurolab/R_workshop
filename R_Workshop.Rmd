---
title: "3/31/2016 UNH R Workshop"
output: 
  html_document: 
    toc: yes
---

This is a document containing materials presented at the 3/31/2016 R workshop

# Prelims


R is a programming language that is especially powerful for data exploration, visualization, and statistical analysis. To interact with R, we use RStudio.

1. Install R by downloading appropriate package from https://cran.r-project.org/index.html
2. Install RStudio by downloading appropriate package from https://www.rstudio.com/products/rstudio/download/




##Install or load packages with one function

```{r, echo=TRUE, message=FALSE, results='hide'}
# ipak function: install and load multiple R packages.
# check to see if packages are installed. Install them if they are not, then load them into the R session.

ipak <- function(pkg){
    new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
    if (length(new.pkg))
        install.packages(new.pkg, dependencies = TRUE)
    sapply(pkg, require, character.only = TRUE)
}

# usage
packages <- c("ggplot2", "psych", "multcomp", "plyr", "lme4", "nlme", "grid", "gridExtra", "devtools")
ipak(packages)
```


##Load packages one by one

```{r, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
library(ggplot2)
library(psych)
library(multcomp)
library(plyr)
library(lme4)
library(nlme)
library(grid)
library(gridExtra)

```

##Load functions you may need

```{r, echo=TRUE, message=FALSE, warning=FALSE}
###### "summarySE"" function for error bars in ggplot2 ##########################



summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE, conf.interval=.95, .drop=TRUE) {
  require(plyr)
  
  # New version of length which can handle NA's: if na.rm==T, don't count them
  length2 <- function (x, na.rm=FALSE) {
    if (na.rm) sum(!is.na(x))
    else       length(x)
  }
  
  # This is does the summary; it's not easy to understand...
  datac <- ddply(data, groupvars, .drop=.drop,
                 .fun= function(xx, col, na.rm) {
                   c( N    = length2(xx[,col], na.rm=na.rm),
                      mean = mean   (xx[,col], na.rm=na.rm),
                      sd   = sd     (xx[,col], na.rm=na.rm)
                   )
                 },
                 measurevar,
                 na.rm
  )
  
  # Rename the "mean" column    
  datac <- rename(datac, c("mean"=measurevar))
  
  datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
  
  # Confidence interval multiplier for standard error
  # Calculate t-statistic for confidence interval: 
  # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
  ciMult <- qt(conf.interval/2 + .5, datac$N-1)
  datac$ci <- datac$se * ciMult
  
  return(datac)
}



# Example of using the function above
#dfc <- summarySE(mydataset, measurevar="Response", groupvars=c("Sex","DOSE"))


####################################################################################


# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
```



#Importing and cleaning data
##Import data

```{r}
#Load dataset
mydataset <- read.csv("Sample-Dose-Effect-Curve.csv")

#Explore dataset
summary(mydataset)
str(mydataset)

```

##Rename columns

```{r}


mydataset<-rename(mydataset, c("IV.Sex"="Sex", "DV.Activity"="Activity", "IV.DOSE"="DOSE", "DV.Response"="Response"))
str(mydataset)

```

##Convert variables to factors

```{r}
mydataset$Subject<-as.factor(mydataset$Subject)
mydataset$DOSE<-as.factor(mydataset$DOSE)

#Explore dataset
summary(mydataset)
str(mydataset)
```


## Rename level of a factor

```{r}
with(mydataset, (levels(Sex)))
mydataset$Sex<-with(mydataset, revalue(Sex, c("Fem"="F")))
str(mydataset)

```


##Subset 

```{r}
### Subset dataset for separate analysis if needed
Female<-subset(mydataset, Sex=="F")
Male<-subset(mydataset, Sex=="M")

summary(Female)
summary(Male)
```


##Basic summary statistics using Psych package

```{r}
#Basic summary statistics by group
with(mydataset, (describeBy(Response, list(DOSE, Sex), mat=TRUE)))
```

##Preliminary visualization 

```{r}
#Boxplot
p<-ggplot(mydataset, aes(factor(DOSE), Response))
p+geom_boxplot()

# save boxplot as bp1
bp1<-ggplot(mydataset, aes(factor(DOSE), Response))+
  geom_boxplot()


#Boxplot with individual data
p<-ggplot(mydataset, aes(factor(DOSE), Response))
p+geom_boxplot() +
geom_jitter()

# save as bp2
bp2<-ggplot(mydataset, aes(factor(DOSE), Response))+
  geom_boxplot() +
  geom_jitter()


#Boxplot: by Sex
p<-ggplot(mydataset, aes(factor(DOSE), Response))
p+geom_boxplot(aes(fill=factor(Sex)))

# save as bp3

bp3<-ggplot(mydataset, aes(factor(DOSE), Response))+
  geom_boxplot(aes(fill=factor(Sex)))


#Line plot: DOSE by Sex

ggplot(mydataset, aes(x=DOSE, y=Response, colour=Sex, group=Sex)) + 
  geom_smooth()
  
  
  
```


#Anovas

* Type I, II, and III can be modeled using "ez" package and a bit of googling or textbook referral
* By default, R uses Type I sums of squares, and SPSS uses Type III sums of squares
* There is a debate out there about what is more appropriate depending on conditions
* Certain assumptions have to be met (homogeneity of variance)
* Distributions within groups should be normally distributed
* General format: aov.model <-aov(outcome ~ predictor(s) + Error, data=dataFrame)
* Error term: Error(Subject/Within Subjects IV) or Error if one between subjects variable - Error(Subject)
* Suggested resourse: http://egret.psychol.cam.ac.uk/statistics/R/anova.html#visualization

```{r}

# Two way mixed factor ANOvA
AnovaModel.1 <- aov(Response ~ Sex*DOSE + Error(Subject/DOSE), data=mydataset)
summary(AnovaModel.1)

# One way Anova with Sex removed
AnovaModel.2 <- aov(Response ~ DOSE + Error(Subject/DOSE), data=mydataset)
summary(AnovaModel.2)


# One way Female only
AnovaModel.3 <- aov(Response ~ DOSE + Error(Subject), data=Female)
summary(AnovaModel.3)


# One way Male only
AnovaModel.4 <- aov(Response ~ DOSE + Error(Subject), data=Male)
summary(AnovaModel.4)


```

#Multilevel approach: multilevel linear model

* See p. 573 of Discovering Statistics Using R, 1st Edition by Andy Field, Jeremy Miles, Zoe Field.
* Well suited to repeated-measures experimental designs
* Can be modeled using _lme()_ function from {nlme} package
* General format: lme.model<-lme(outcome ~ predictor(s), random = random effects, data = dataFrame, method="ML")
* The default method is restricted maximum-likelihood estimation (REML)
* For various reasons I am not competent enough to discuss here, the advised method is maximum likelihood (ML)
* "random" specifies any random effects - an effect that can vary across different entities
* In the example below we have _random=~1 | Subject/DOSE/Sex_ which means that the data with the same value of _Subject_ within different levels of _DOSE_ or _Sex_ are dependent (i.e., from the same subject)

##Step by Step: Using multilevel approach

1. Build a model from a baseline that includes no predictors other than intercept.
2. Add predictor 1 (DOSE)
3. Add predictor 2 (Sex)
4. Add interaction (Dose:Sex)
5. Compare models to the baseline using anova
6. Determine if adding predictors and/or interaction significantly improved the model**
7. Run appropriate "summary" on the model of interest which will give you all the effects and comparisons***

** When added predictor significantly improves a model, in other words the predictor had a significant effect on dependent measure, we can record this as such:

$$\chi^2(2)=9.1, p=.010$$

Where (2) is an increase of degrees of freedom from baseline, in this case by 2

*** When reporting contrasts from "summary" output we can print it as such:

$$b=2.19, t(38)=3.18, p=.003$$

See Andy Field pages 595-596


```{r}

# Build a baseline: no predictors other than the intercept

baseline<-lme(Response~1, random=~1 | Subject/DOSE/Sex, data=mydataset, method="ML")

# note that the outcome is predicted only from the intercept (Response~1)
# and we asked to use ML to estimate the model
# the variables DOSE/Sex are nested within the variable Subject (scores for levels of thes variables can be found within each Sbuject)
# to see the effect of each predictor we need to add them one by one
# lets add "DOSE" variable to the model

doseModel<-update(baseline, .~. +DOSE)

# note that we created new model "doseModel" so we can compare it to "baseline" above if need it
# note that we used update function to simply update the model above without rewriting most of it
# next, we can keep buildign the modely by adding "Sex" variable to the "doseModel"


sexModel<-update(doseModel, .~. +Sex)

# note that we created a new model "sexModel" using "update" function
# next, lets add interaction term

mixModel<-update(sexModel, .~. +DOSE:Sex)

# to compare these models we can list them in the order in which we want them to be compared using anova() function

anova(baseline, doseModel, sexModel, mixModel)

# We can further explore the model by runnign summary function

summary(doseModel) 

# this give us all the comparisons to 0 we need!
# next lets explore sexModel

summary(sexModel)

# looks like there "Sex" did not significantly contribued to the variance
# finally lets explore mixModel

summary(mixModel)


```


#Publication quality figures 
##converting to boring black and white style

```{r fig.width=11, fig.height=8}

# Firs we need to get SEM so we can use it for the error bars
# make sure you run "summarySE" function above first or check Environment->Functions to see if it is loaded if you like to run the code below by itself. No need to worry if you are "Kitting" this code (see Knit option above this window)
# lets extract means and SE for the variables we need to plot and save them under dfc

dfc <- summarySE(mydataset, measurevar="Response", groupvars=c("Sex","DOSE"))

#lets see what dfc looks like

dfc

# lets assign position_dodge value if we need it later on to nudge error bars a bit 

pd <- position_dodge(0.2) 

# build a ggplot function

p<-ggplot(data=dfc, aes(x=DOSE, y=Response, colour=Sex, group=Sex)) 

# add points

p<-p+geom_point()


# print p

p

# add lines

p<-p+geom_line()

# print p

p

# put this all together

p1<-ggplot(data=dfc, aes(x=DOSE, y=Response, colour=Sex, group=Sex)) +
  geom_line()+
  geom_point()

p1


#change lines and points

ggplot(data=dfc, aes(x=DOSE, y=Response, colour=Sex, group=Sex)) +
  geom_line(size=3)+
  geom_point(size=10, aes(shape=Sex, fill=Sex))

# convert to boring black and white

p2<-ggplot(data=dfc, aes(x=DOSE, y=Response, group=Sex, shape=Sex)) +
  geom_errorbar(aes(ymin=Response-se, ymax=Response+se), width=0.1, position=pd)+
  geom_line(aes(linetype=Sex), size=1, position=pd)+       # Set linetype by sex
  geom_point(size=5, position=pd) +
  expand_limits(y=0) +                        # Set y range to include 0
  xlab("Bupropion Dose") + ylab("Responding") +  # Set axis labels
  ggtitle("Bupropion Dose Effect Curve") +       # Set title
  theme_bw() + # Set size of title and labels
  labs(title = "Bupropion Dose Effect Curve") # main title

p2

# Remove grids

p3<-p2+theme(axis.line = element_line(colour = "black", size=2), # adjust the appearance of lines and remove grids
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank()) 

p3



```

##Output figures

```{r}

## creates multiple figures per defined page

svg(filename="Figure-1.svg", width = 10, height = 10.8)
plot<-multiplot(bp1, bp2, bp3, p1, p2, p3, cols=2) # requires multiplot function
dev.off()

png(filename="Figure-2.png", width = 1275, height = 5300, units = "px", res=300, type = "cairo")
plot<-multiplot(bp1, bp2, bp3, p1, p2, p3, cols=1)
dev.off()

tiff(filename="Figure-3.tiff", width = 1275, height = 5300, units = "px", res=300, type = "cairo")
plot<-multiplot(bp1, bp2, bp3, p1, p2, p3, cols=1)
dev.off()

pdf("Figure-4.pdf", width = 5, height = 18, useDingbats=FALSE)
plot<-multiplot(bp1, bp2, bp3, p1, p2, p3, cols=1)
dev.off()


## creates one plot per page
pdf(file = "figure-5-pages.pdf")
bp1
bp2
bp3
p1
p2
p3
dev.off()

```


```{r}
devtools::session_info()
```

